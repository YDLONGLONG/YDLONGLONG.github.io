<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>初级Vue面试(2022)</title>
      <link href="/2021/07/26/%E5%88%9D%E7%BA%A7Vue%E9%9D%A2%E8%AF%95-2022/"/>
      <url>/2021/07/26/%E5%88%9D%E7%BA%A7Vue%E9%9D%A2%E8%AF%95-2022/</url>
      
        <content type="html"><![CDATA[<p>1.var let const 的区别<br>var 会变量提升 let 和 const 不会<br>var 在全局命名的变量会挂载到 window 上，let const 不会<br>let 和 const 有块级作用域（暂时性死去），var 没有<br>let const 不允许重复命名</p><p>2.Vue 里面 computed 是什么东西怎么用？<br>在 vue 模板里面是有表达式是非常便利的，但是设计他们的初衷是用来简单运算的。在实际的开发过程中在模板里放入过多的表达式会让项目的可维护性大大降低。</p><span id="more"></span><p><img src="/images/pasted-3.png" alt="upload successful"></p><p>对于这种复杂的计算单数据，我们应该使用计算属性来解决；<br>计算属性中的方法是依赖于其中的值的，当计算属性中的值变化的时候，计算属性会更新</p><p><img src="/images/pasted-4.png" alt="upload successful"></p><p>当 this.data 的值发生变化大时候，他所依赖的计算属性 reversedMessage 会重新计算并调用</p><p>3.Vue 里面的 watch 是什么东西怎么使用？<br>虽然计算属性在大部分情况下都适用，但是在实际开发过程中需要一些自定义的监听器，当需要在执行异步或者开销比较大的操作中，监听器比计算属性更加有效。</p><p><img src="/images/pasted-5.png" alt="upload successful"></p><p>4.watch和computed的区别<br>计算属性和监听属性都是希望在依赖数据变化的时候，被依赖的数据根据事先设定好的函数发生自动的变换。 watch 一个数据相应多个数据 computed 一个数据受到多个数据的影响 在实现原理上watch和computed是差不多的，vue 的data值在初始化阶段都会被挂载上 watcher 观察者模式，当数据改变的时候先调用watcher观察者模式，然后调用计算属性，和监听属性。本质上来说没有多大区别</p><p>5.请说出 vue 几种常用的指令<br>v-if：根据表达式的值的真假条件渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。</p><p>v-show：根据表达式之真假值，切换元素的 display CSS 属性。</p><p>v-for：循环指令，基于一个数组或者对象渲染一个列表，vue 2.0 以上必须需配合 key 值 使用。</p><p>v-bind：动态地绑定一个或多个特性，或一个组件 prop 到表达式。</p><p>v-on：用于监听指定元素的 DOM 事件，比如点击事件。绑定事件监听器。</p><p>v-model：实现表单输入和应用状态之间的双向绑定</p><p>v-pre：跳过这个元素和它的子元素的编译过程。可以用来显示原始</p><p>Mustache 标签。跳过大量没有指令的节点会加快编译。</p><p>v-once：只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</p><p>6.v-if 和 v-show 有什么区别<br>共同点：</p><p>v-if 和 v-show 都是动态显示 DOM 元素。</p><p>区别：</p><p>1、编译过程： v-if 是 真正 的 条件渲染，因为它会确保在切换过程中条件块 内的事件监听器和子组件适当地被销毁和重建。v-show 的元素始终会被渲染并 保留在 DOM 中。 v-show 只是简单地切换元素的 CSS 属性 display。</p><p>2、编译条件： v-if 是惰性的：如果在初始渲染时条件为假，则什么也不做。直 到条件第一次变为真时，才会开始渲染条件块。v-show 不管初始条件是什么， 元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p><p>3、性能消耗： v-if 有更高的切换消耗。v-show 有更高的初始渲染消耗。</p><p>4、应用场景： v-if 适合运行时条件很少改变时使用。v-show 适合频繁切换。</p><p>7.vue 中子组件调用父组件的方法<br>通过 v-on 监听 和emit’触发 当前实例上的 自定义事件。 示例： 父组件：</p><p><img src="/images/pasted-6.png" alt="upload successful"></p><p><img src="/images/pasted-7.png" alt="upload successful"></p><p>8.axios 有哪些特点？<br>1、Axios 是一个基于 promise 的 HTTP 库，支持 promise 所有的 API</p><p>2、它可以拦截请求和响应</p><p>3、它可以转换请求数据和响应数据，并对响应回来的内容自动转换成 JSON 类 型的数据</p><p>4、安全性更高，客户端支持防御 XSRF</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>es6-Promise解决回调地狱</title>
      <link href="/2021/07/25/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2021/07/25/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>1、什么是回调地狱?<br>假如我们有很多异步事件，而这些异步事件又有很紧密的联系，比如一个异步事件要依赖另一个异步事件的返回值，看下面的：</p><span id="more"></span><p><img src="/images/pasted-0.png" alt="upload successful"></p><p>是不是进入了一环套一环的地狱里面。我们可以简单处理下：</p><p><img src="/images/pasted-1.png" alt="upload successful"><br>这样虽然把每个ajax请求放在了函数里面，不用把所有请求放在一个方法里面，但实际上还是在函数里面一层一层的嵌套来实现，很不便于阅读和维护。</p><p>2、看看promise是如何解决的<br>promise的出现就是为了解决异步编程中的回调问题，它提供了统一的 API</p><p><img src="/images/pasted-2.png" alt="upload successful"><br>这就很很好的解决了回调地狱的问题</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/07/25/hello-world/"/>
      <url>/2021/07/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
